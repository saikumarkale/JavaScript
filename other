const fp = require('fastify-plugin');
const fs = require('fs');
const fileHandlerPlugin = require('./fileHandlerPlugin'); // Assuming fileHandlerPlugin.js is the filename

// Mock fastify instance
const fastifyMock = {
  log: {
    trace: jest.fn(),
    error: jest.fn(),
  },
  decorate: jest.fn(),
};

// Mock fs.unlink method
jest.mock('fs', () => ({
  existsSync: jest.fn(),
  unlink: jest.fn(),
}));

describe('fileHandlerPlugin', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should decorate fastify instance with deleteFile method', () => {
    fileHandlerPlugin(fastifyMock);
    expect(fastifyMock.decorate).toHaveBeenCalledWith('deleteFile', expect.any(Function));
  });

  it('should delete file if it exists', async () => {
    const filePath = '/path/to/file.txt';
    fs.existsSync.mockReturnValue(true);
    fs.unlink.mockImplementation((filePath, callback) => callback(null)); // Mocking success
    await fastifyMock.deleteFile(filePath);
    expect(fs.existsSync).toHaveBeenCalledWith(filePath);
    expect(fs.unlink).toHaveBeenCalledWith(filePath, expect.any(Function));
    expect(fastifyMock.log.trace).toHaveBeenCalledWith(`file deleted from ${filePath}`);
  });

  it('should handle error if file deletion fails', async () => {
    const filePath = '/path/to/file.txt';
    const error = new Error('File deletion failed');
    fs.existsSync.mockReturnValue(true);
    fs.unlink.mockImplementation((filePath, callback) => callback(error)); // Mocking error
    await expect(fastifyMock.deleteFile(filePath)).rejects.toThrowError(error);
    expect(fs.existsSync).toHaveBeenCalledWith(filePath);
    expect(fs.unlink).toHaveBeenCalledWith(filePath, expect.any(Function));
    expect(fastifyMock.log.error).toHaveBeenCalledWith('Error while deleting document file');
  });

  it('should not attempt to delete file if it does not exist', async () => {
    const filePath = '/path/to/nonexistent_file.txt';
    fs.existsSync.mockReturnValue(false);
    await fastifyMock.deleteFile(filePath);
    expect(fs.existsSync).toHaveBeenCalledWith(filePath);
    expect(fs.unlink).not.toHaveBeenCalled();
  });
});